Description: fix compilation on hurd-i386
 Do not rely on MAXPATHLEN to be defined. Instead iteratively call getcwd()
 with an increasing buffer size until the current path fits.
Bug-Debian: http://bugs.debian.org/624779
Origin: upstream, backport of 64e690fd0e14f6a0ad816d8fd55044f36d8559d5,
 d23dbf2ce78cd11fc1a1dc85cd78cc28ab2df8ca and
 c14cb021dafa331f859634a14087f6f81d870aed
============================================================
--- a/src/netxx/serverbase.cxx
+++ b/src/netxx/serverbase.cxx
@@ -44,6 +44,9 @@
 #include "probeinfo.h"
 #include "socket.h"
 
+// Monotone specific, for get_current_working_dir()
+#include <src/platform.hh>
+
 // standard includes
 #include <map>
 #include <vector>
@@ -167,14 +170,16 @@
 		if (saun->sun_path[0] == '/') {
 		    files_.push_back(saun->sun_path);
 		} else {
-		    char buffer[MAXPATHLEN];
-
-		    if (getcwd(buffer, sizeof(buffer))) {
- 			std::string fullpath = buffer; fullpath += '/'; fullpath += saun->sun_path;
-			files_.push_back(fullpath);
-		    } else {
-			files_.push_back(saun->sun_path);
-		    }
+		    /*
+		     * the original (netxx) code here relied on MAXPATHLEN,
+		     * which isn't defined on hurd. As netxx seems to only
+		     * live on within monotone, we can as well make it
+		     * inter-dependent. And the unix/fs.cc variant certainly
+		     * gets more test mileage than anything special here.
+		     */
+		    std::string fullpath = get_current_working_dir();
+		    fullpath += '/'; fullpath += saun->sun_path;
+		    files_.push_back(fullpath);
 		}
 	    }
 #	endif
--- a/src/unix/fs.cc
+++ b/src/unix/fs.cc
@@ -41,14 +41,26 @@
 string
 get_current_working_dir()
 {
-  char buffer[4096];
-  if (!getcwd(buffer, 4096))
+  std::vector<char> cwd_buf;
+  size_t cwd_sz = 4096;
+
+  // This funny loop prevents having to specify a MAXPATHLEN or similar, but
+  // uses a dynamic approach, repeatedly calling getcwd() until our buffer
+  // is big enough for the current path to fit. Think of it as a portable
+  // replacement for get_current_dir_name(), which is GNU-only.
+  do
     {
-      const int err = errno;
-      E(false, origin::system,
-        F("cannot get working directory: %s") % os_strerror(err));
+      cwd_buf.resize(cwd_sz);
+      if (getcwd(&cwd_buf[0], cwd_sz))
+        return string(&cwd_buf[0]);
+
+      cwd_sz += 4096;
     }
-  return string(buffer);
+  while (errno == ERANGE);
+
+  const int err = errno;
+  E(false, origin::system,
+    F("cannot get working directory: %s") % os_strerror(err));
 }
 
 void
